<?php

namespace App\Mappers;

use App\Models\ItemCatalog;
use App\Models\ItemType;
use App\UnitOfWork\UnitOfWork;
use App\IdentityMap\IdentityMap;
use App\Gateway\ItemGateway;
use App\Gateway\ComputerGateway;
use App\Gateway\DesktopGateway;
use App\Gateway\LaptopGateway;
use App\Gateway\TabletGateway;
use App\Gateway\MonitorGateway;

abstract class ItemCatalogMapper {

    private const DOMAIN_STORAGE_ARRAY_KEY_PAIRS = [
        ["id", "id"],
        ["category", "category"],
        ["brand", "brand"],
        ["price", "price"],
        ["quantity", "quantity"],
        ["displaySize", "display_size"],
        ["weight", "weight"],
        ["height", "height"],
        ["width", "width"],
        ["thickness", "thickness"],
        ["processorType", "processor_type"],
        ["ramSize", "ram_size"],
        ["cpuCores", "cpu_cores"],
        ["hddSize", "hdd_size"],
        ["os", "os"],
        ["battery", "battery"],
        ["camera", "camera"],
        ["isTouchscreen", "is_touchscreen"]
    ];
    private static $instance;
    private $itemCatalog;
    private $unitOfWork;
    private $identityMap;

    private function __constructor() {
        $this->itemCatalog = ItemCatalog::getInstance();
        $this->identityMap = IdentityMap::getInstance();
        $this->unitOfWork = UnitOfWork::getInstance();
        $this->updateCatalog();
    }

    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new ItemCatalogMapper();
        }
        return self::$instance;
    }

    // Used by the controllers
    public function addNewItem($transactionId, $itemType, $param) {
        $paramArray = $param;
        $paramArray["id"] = "new";
        $item = $this->itemCatalog->createItem($itemType, $paramArray);
        $this->unitOfWork->registerNew($transactionId, $this->instance, $item);
    }

    // Used by the controllers
    public function removeItem($transactionId, $itemId) {
        $item = $this->itemCatalog->getItem($itemId);
        $this->unitOfWork->registerDeleted($transactionId, $item->getId(), $this->instance, $item);
    }

    // Used by the controllers
    public function modifyItem($transactionId, $itemId, $param) {
        $item = $this->itemCatalog->getItem($itemId);
        $this->unitOfWork->registerDirty($transactionId, $item->getId(), $this->instance, $item);
    }

    // Used by the controllers
    public function commit($transactionId) {
        $this->unitOfWork->commit($transactionId);
    }

    // Used by the controllers
    public function getItem($itemId){
        $item = $this->itemCatalog->getItem($itemId);
        if ($item === null) {
            return null;
        } else {
            return $this->mapItemToDomainArray($item);
        }
    }

    public function selectAllItems() {
        $this->updateCatalog();
        $items = $this->itemCatalog->getAllItems();
        return $this->mapItemArrayToDomainArrays($items);
    }

    // Used by the controllers. Here the item type is a code where:
    // item = 0;
    // monitor = 1;
    // computer = 2;
    // desktop = 3;
    // laptop = 4;
    // tablet = 5;
    // Since we have a server rendered app, I suggest using the ItemType enum directly from the controllers to generate the item type.
    public function selectAllItemType($itemType) {
        $this->updateCatalog();
        $items = $this->itmeCatalog->getAllItemsType($itemType);
        return $this->mapItemArrayToDomainArrays($items);
    }

    // Used by the unitofwork when commit happens
    public function add($item) {
        $gateway = $this->getGateway($item);
        if ($gateway === null) {
            return false;
        }
        $domainArray = $this->mapItemToDomainArray($item);
        if ($domainArray === null) {
            return false;
        }
        // We remove the key-value pair for "id" since the new item doesn't have a meaningful ID yet (ID are generated by the DB)
        unset($domainArray["id"]);
        $param = $this->mapDomainArrayToStorage($domainArray);
        $id = $gateway->insert($param);
        if ($this->identityMap->hasId($id)){
            return false;
        }
        $item->setId($id);
        $this->identityMap->set($id, $item);
        $this->itemCatalog->addItem($item);
    }

    // Used by the unitofwork when commit happens
    public function delete($item) {
        $gateway = $this->getGateway($item);
        if ($gateway === null) {
            return false;
        }
        $id = $item->getId();
        $deleted = $gateway->deleteById($id);
        if ($deleted) {
            $this->identityMap->removeObject($id);
            $this->itemCatalog->removeItem($id);
        }

    }

    // Used by the unitofwork when commit happens
    // NOTE: CURRENTLY, THE ITEM IN THE UNIT OF WORK POINTS TOWARDS THE ITEM IN THE IDENTITY MAP.
    // NEED TO DECOUPLE THOSE TWO FOR THIS METHOD TO BE USEFUL!
    public function edit($item) {
        $gateway = $this->getGateway($item);
        if ($gateway === null) {
            return false;
        }
        $domainArray = $this->mapItemToDomainArray($item);
        $param = $this->mapDomainArrayToStorage($domainArray);
        $gateway->update($param);
        $this->itemCatalog->editItem($item.getId(), $domainArray);
    }

    private function updateCatalog() {

        // GENERATING AN ARRAY OF ALL THE ITEMS IN THE DATABASE
        $itemsArray = array();
        $desktopGateway = new DesktopGateway();
        $desktops = $desktopGateway->getAll();
        foreach($desktops as $desktop) {
            $itemsArray[] = $this->mapStorageArrayToDomain($desktop);
        }
        $laptopGateway = new LaptopGateway();
        $laptops = $laptopGateway->getAll();
        foreach($laptops as $laptop) {
            $itemsArray[] = $this->mapStorageArrayToDomain($laptop);
        }
        $tabletGateway = new TabletGateway();
        $tablets = $laptopGateway->getAll();
        foreach($tablets as $talbet) {
            $itemsArray[] = $this->mapStorageArrayToDomain($tablet);
        }

        // POPULATING THE CATALOG WITH THE RESULTS
        $unvisitedKeysInCatalog = $this->itemCatalog->getCatalogKeys();
        foreach($itemsArray as $itemParamsArray) {
            $itemType = ItemType::getItemTypeStringToEnum($itemParamsArray["category"]);
            $itemId = $itemParamsArray["id"];
            if ($this->itemCatalog->isItemIdInCatalog($itemId)) {
                $this->itemCatalog->editItem($itemId, $itemParamsArray);
                unset($unvisitedKeysInCatalog[$itemId]);
            } else {
                $item = $this->itemCatalog->create($itemType, $itemParamsArray);
                $this->itemCatalog->addItem($item);
            }
        }

        // REMOVING THE KEYS THAT HAVN'T BEEN VISITED (MEANING THEY ARE IN THE CATALOG BUT NOT IN DB)
        foreach($unvisitedKeysInCatalog as $key => $value) {
            $this->identityMap->removeObject($key);
            $this->itemCatalog->removeItem($key);
        }

    }

    private function getGateway($item) {
        $itemType = ItemType::getItemTypeEnum($item);
        switch($itemType) {
            case ItemType::item:
            return new ItemGateway();
            break;
            case ItemType::monitor:
            return new MonitorGateway();            
            break;
            case ItemType::computer:
            return new ComputerGateway();            
            break;
            case ItemType::desktop:
            return new DesktopGateway();            
            break;
            case ItemType::laptop:
            return new LaptopGateway();            
            break;
            case ItemType::tablet:
            return new TabletGateway();            
            break;
            default:
            return null;
        }
    }

    private function mapItemArrayToDomainArrays($itemArray) {
        $arrayToReturn = array();
        foreach($itemArray as $item) {
            $arrayToReturn[] = $this->mapItemToDomainArray($item);
        }
        return $arrayToReturn;
    }

    private function mapItemToDomainArray($item) {
        if ($item !== null) {
            $itemType = ItemType::getItemType($item);
            switch($itemType) {
                case ItemType::item:
                return $this->getItemParams($item);
                case ItemType::monitor:
                return $this->getMonitorParams($item);
                case ItemType::computer:
                return $this->getComputerParams($item);
                case ItemType::desktop:
                return $this->getDesktopParams($item);
                case ItemType::laptop:
                return $this->getLaptopParams($item);
                case ItemType::tablet:
                return $this->getTabletParams($item);
                default:
                return null;
            }
        } else {
            return null;
        }
    }

    private function mapDomainArrayToStorage($domainArray) {
        $storageArray = null;
        foreach (self::DOMAIN_STORAGE_ARRAY_KEY_PAIRS as $pair){
            $domainKeyValue = $pair[0];
            $storageKeyValue = $pair[1];
            if ($this->keyExists($domainKeyValue, $domainArray)) {
                $storageArray[$storageKeyValue] = $domainArray[$domainKeyValue];
            }
        }
        return $storageArray;
    }

    private function mapStorageArrayToDomain($storageArray) {
        $domainArray = null;
        foreach (self::DOMAIN_STORAGE_ARRAY_KEY_PAIRS as $pair){
            $domainKeyValue = $pair[0];
            $storageKeyValue = $pair[1];
            if ($this->keyExists($storageKeyValue, $storageArray)) {
                $domainArray[$domainKeyValue] = $storageArray[$storageKeyValue];
            }
        }
        return $domainArray;
    }

    private function keyExists($key, $array) {
        if ($key !== null) {
            return array_key_exists($key, $array);
        } else {
            return false;
        }
    }

    private function getItemParams($item) {
        $array = array();
        $array["id"] = $item->getId();
        $array["category"] = $item->getCategory();
        $array["brand"] = $item->getBrand();
        $array["price"] = $item->getPrice();
        $array["quantity"] = $item->getQuantity();
        return $array;
    }

    private function getMonitorParams($item) {
        $array = $this->getItemParams($item);
        $array["displaySize"] = $item->getDisplaySize();
        $array["weight"] = $item->getWeight();
        return $array;
    }

    private function getComputerParams($item) {
        $array = $this->getItemParams($item);
        $array["processorType"] = $item->getProcessorType();
        $array["ramSize"] = $item->getRamSize();
        $array["cpuCores"] = $item->getCpuCores();
        $array["weight"] = $item->getWeight();
        $array["hddSize"] = $item->getHddSize();
        return $array;        
    }

    private function getDesktopParams($item) {
        $array = $this->getComputerParams($item);
        $array["height"] = $item->getHeight();
        $array["width"] = $item->getWidth();
        $array["thickness"] = $item->getThickness();
        return $array;        
    }

    private function getLaptopParams($item) {
        $array = $this->getComputerParams($item);
        $array["displaySize"] = $item->getDisplaySize();
        $array["os"] = $item->getOs();
        $array["battery"] = $item->getBattery();
        $array["camera"] = $item->getCamera();
        $array["isTouchscreen"] = $item->getIsTouchscreen();
        return $array;        
    }

    private function getTabletParams($item) {
        $array = $this->getComputerParams($item);
        $array["height"] = $item->getHeight();
        $array["width"] = $item->getWidth();
        $array["thickness"] = $item->getThickness();
        $array["displaySize"] = $item->getDisplaySize();
        $array["os"] = $item->getOs();
        $array["battery"] = $item->getBattery();
        $array["camera"] = $item->getCamera();
        $array["isTouchscreen"] = $item->getIsTouchscreen();
        return $array;        
    }

}